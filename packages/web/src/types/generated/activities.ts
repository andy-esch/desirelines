// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.33.0
// source: activities.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "desirelines.activities.v1";

/**
 * Timeseries entry for distance data
 * Represents cumulative distance over time
 */
export interface TimeseriesEntry {
  /** ISO 8601 date string (e.g., "2025-01-15") */
  date: string;
  /** Distance in miles (cumulative) */
  value: number;
}

/**
 * Distance data payload consumed by frontend
 * This is the primary data contract between backend and frontend
 *
 * Backend Producer:
 *   - Python: packages/stravapipe/src/stravapipe/application/aggregator/services/pacing_service.py
 *   - Function: PacingService.calculate()
 *   - Storage: activities/{year}/distances.json in Cloud Storage
 *
 * API Gateway:
 *   - Go: packages/apigateway/handler.go
 *   - Endpoint: GET /activities/{year}/distances
 *
 * Frontend Consumer:
 *   - TypeScript: packages/web/src/api/activities.ts
 *   - Function: fetchDistanceData()
 *   - Type: RideBlobType (maps to this proto)
 *   - Used by: DistanceChartRecharts and PacingChartRecharts
 *
 * Note: Pacing calculations (daily pace, goal pacing) are computed client-side
 *       from the distance_traveled data. See packages/web/src/utils/goalCalculations.ts
 */
export interface DistancesPayload {
  /**
   * Actual cumulative distance traveled over time
   * This is the primary data series - all other data can be derived from this
   */
  distanceTraveled: TimeseriesEntry[];
  /**
   * Legacy fields - kept for backward compatibility but may be removed in future
   * These are no longer generated by the backend (empty arrays)
   */
  avgDistance: TimeseriesEntry[];
  /** Deprecated: use user goals instead */
  lowerDistance: TimeseriesEntry[];
  /** Deprecated: use user goals instead */
  upperDistance: TimeseriesEntry[];
  /**
   * Daily activity summaries keyed by date (ISO 8601 string)
   * Not currently used by frontend but available for future features
   */
  summaries: { [key: string]: DailySummary };
}

export interface DistancesPayload_SummariesEntry {
  key: string;
  value?: DailySummary | undefined;
}

/**
 * Daily summary for a specific date
 * Provides raw activity metadata for a single day
 */
export interface DailySummary {
  /** Strava activity IDs for this day */
  activityIds: string[];
  /** Total distance for this day (not cumulative) */
  distanceMiles: number;
}

/**
 * Summary object for an entire year
 * Stored separately from distances payload
 *
 * Storage: activities/{year}/summary_activities.json
 * Endpoint: GET /activities/{year}/summary
 */
export interface YearSummary {
  /** Daily summaries keyed by date (ISO 8601 string, e.g., "2025-01-15") */
  dailySummaries: { [key: string]: DailySummary };
}

export interface YearSummary_DailySummariesEntry {
  key: string;
  value?: DailySummary | undefined;
}

function createBaseTimeseriesEntry(): TimeseriesEntry {
  return { date: "", value: 0 };
}

export const TimeseriesEntry: MessageFns<TimeseriesEntry> = {
  encode(message: TimeseriesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeseriesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeseriesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDistancesPayload(): DistancesPayload {
  return { distanceTraveled: [], avgDistance: [], lowerDistance: [], upperDistance: [], summaries: {} };
}

export const DistancesPayload: MessageFns<DistancesPayload> = {
  encode(message: DistancesPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.distanceTraveled) {
      TimeseriesEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.avgDistance) {
      TimeseriesEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.lowerDistance) {
      TimeseriesEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.upperDistance) {
      TimeseriesEntry.encode(v!, writer.uint32(34).fork()).join();
    }
    Object.entries(message.summaries).forEach(([key, value]) => {
      DistancesPayload_SummariesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistancesPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistancesPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.distanceTraveled.push(TimeseriesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.avgDistance.push(TimeseriesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lowerDistance.push(TimeseriesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.upperDistance.push(TimeseriesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = DistancesPayload_SummariesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.summaries[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDistancesPayload_SummariesEntry(): DistancesPayload_SummariesEntry {
  return { key: "", value: undefined };
}

export const DistancesPayload_SummariesEntry: MessageFns<DistancesPayload_SummariesEntry> = {
  encode(message: DistancesPayload_SummariesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DailySummary.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DistancesPayload_SummariesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDistancesPayload_SummariesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DailySummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDailySummary(): DailySummary {
  return { activityIds: [], distanceMiles: 0 };
}

export const DailySummary: MessageFns<DailySummary> = {
  encode(message: DailySummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.activityIds) {
      writer.uint32(10).string(v!);
    }
    if (message.distanceMiles !== 0) {
      writer.uint32(17).double(message.distanceMiles);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailySummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailySummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.activityIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.distanceMiles = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseYearSummary(): YearSummary {
  return { dailySummaries: {} };
}

export const YearSummary: MessageFns<YearSummary> = {
  encode(message: YearSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.dailySummaries).forEach(([key, value]) => {
      YearSummary_DailySummariesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YearSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYearSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = YearSummary_DailySummariesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.dailySummaries[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseYearSummary_DailySummariesEntry(): YearSummary_DailySummariesEntry {
  return { key: "", value: undefined };
}

export const YearSummary_DailySummariesEntry: MessageFns<YearSummary_DailySummariesEntry> = {
  encode(message: YearSummary_DailySummariesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DailySummary.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YearSummary_DailySummariesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYearSummary_DailySummariesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DailySummary.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
