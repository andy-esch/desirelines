// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.33.0
// source: sports_metrics.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "desirelines.sports.v1";

/** Single timeseries entry (date + value) */
export interface TimeseriesEntry {
  /** ISO date: "2024-01-15" */
  date: string;
  /** Metric value */
  value: number;
}

/** Daily activity summary */
export interface DailyActivity {
  /**
   * Distance in METERS (optional - not all sports have distance)
   * SI base unit: matches Strava API, no conversion errors
   */
  distanceMeters?:
    | number
    | undefined;
  /** Time in minutes */
  timeMinutes?:
    | number
    | undefined;
  /** Elevation gain in METERS (optional) */
  elevationMeters?:
    | number
    | undefined;
  /** Number of activities on this day */
  activities: number;
  /** Strava activity IDs */
  activityIds: number[];
}

/** Pre-computed timeseries for efficient chart rendering */
export interface MetricsTimeseries {
  distanceMeters: TimeseriesEntry[];
  timeMinutes: TimeseriesEntry[];
  elevationMeters: TimeseriesEntry[];
}

/** Sport metrics file (activities/{year}/metrics/{sport}.json) */
export interface SportMetrics {
  /** Pre-computed timeseries arrays */
  timeseries?:
    | MetricsTimeseries
    | undefined;
  /** Daily rollups (date-keyed) */
  daily: { [key: string]: DailyActivity };
  /** Metadata */
  metadata?: SportMetadata | undefined;
}

export interface SportMetrics_DailyEntry {
  key: string;
  value?: DailyActivity | undefined;
}

/** Metadata about the sport metrics */
export interface SportMetadata {
  /** "cycling", "running", "yoga" */
  sport: string;
  /** 2024 */
  year: number;
  /** ["distance_meters", "time_minutes", ...] */
  availableMetrics: string[];
  /** "distance_meters" */
  primaryMetric: string;
}

/** Sport totals for a year */
export interface SportTotals {
  distanceMeters?: number | undefined;
  timeMinutes?: number | undefined;
  elevationMeters?: number | undefined;
  activities: number;
}

/** Year metadata file (activities/{year}/metadata.json) */
export interface YearMetadata {
  year: number;
  /** ["cycling", "running", "yoga"] */
  sports: string[];
  /** Per-sport totals */
  totals: { [key: string]: SportTotals };
  /** ISO timestamp */
  lastUpdated: string;
  /** "1.0" */
  aggregationVersion: string;
}

export interface YearMetadata_TotalsEntry {
  key: string;
  value?: SportTotals | undefined;
}

function createBaseTimeseriesEntry(): TimeseriesEntry {
  return { date: "", value: 0 };
}

export const TimeseriesEntry: MessageFns<TimeseriesEntry> = {
  encode(message: TimeseriesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.date !== "") {
      writer.uint32(10).string(message.date);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeseriesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeseriesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.date = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDailyActivity(): DailyActivity {
  return {
    distanceMeters: undefined,
    timeMinutes: undefined,
    elevationMeters: undefined,
    activities: 0,
    activityIds: [],
  };
}

export const DailyActivity: MessageFns<DailyActivity> = {
  encode(message: DailyActivity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distanceMeters !== undefined) {
      writer.uint32(9).double(message.distanceMeters);
    }
    if (message.timeMinutes !== undefined) {
      writer.uint32(17).double(message.timeMinutes);
    }
    if (message.elevationMeters !== undefined) {
      writer.uint32(25).double(message.elevationMeters);
    }
    if (message.activities !== 0) {
      writer.uint32(32).int32(message.activities);
    }
    writer.uint32(42).fork();
    for (const v of message.activityIds) {
      writer.int64(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DailyActivity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDailyActivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.distanceMeters = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.timeMinutes = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.elevationMeters = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.activities = reader.int32();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.activityIds.push(longToNumber(reader.int64()));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.activityIds.push(longToNumber(reader.int64()));
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseMetricsTimeseries(): MetricsTimeseries {
  return { distanceMeters: [], timeMinutes: [], elevationMeters: [] };
}

export const MetricsTimeseries: MessageFns<MetricsTimeseries> = {
  encode(message: MetricsTimeseries, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.distanceMeters) {
      TimeseriesEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.timeMinutes) {
      TimeseriesEntry.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.elevationMeters) {
      TimeseriesEntry.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricsTimeseries {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsTimeseries();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.distanceMeters.push(TimeseriesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timeMinutes.push(TimeseriesEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.elevationMeters.push(TimeseriesEntry.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSportMetrics(): SportMetrics {
  return { timeseries: undefined, daily: {}, metadata: undefined };
}

export const SportMetrics: MessageFns<SportMetrics> = {
  encode(message: SportMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeseries !== undefined) {
      MetricsTimeseries.encode(message.timeseries, writer.uint32(10).fork()).join();
    }
    Object.entries(message.daily).forEach(([key, value]) => {
      SportMetrics_DailyEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.metadata !== undefined) {
      SportMetadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SportMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSportMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeseries = MetricsTimeseries.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SportMetrics_DailyEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.daily[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = SportMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSportMetrics_DailyEntry(): SportMetrics_DailyEntry {
  return { key: "", value: undefined };
}

export const SportMetrics_DailyEntry: MessageFns<SportMetrics_DailyEntry> = {
  encode(message: SportMetrics_DailyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      DailyActivity.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SportMetrics_DailyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSportMetrics_DailyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = DailyActivity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSportMetadata(): SportMetadata {
  return { sport: "", year: 0, availableMetrics: [], primaryMetric: "" };
}

export const SportMetadata: MessageFns<SportMetadata> = {
  encode(message: SportMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sport !== "") {
      writer.uint32(10).string(message.sport);
    }
    if (message.year !== 0) {
      writer.uint32(16).int32(message.year);
    }
    for (const v of message.availableMetrics) {
      writer.uint32(26).string(v!);
    }
    if (message.primaryMetric !== "") {
      writer.uint32(34).string(message.primaryMetric);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SportMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSportMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sport = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.availableMetrics.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.primaryMetric = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseSportTotals(): SportTotals {
  return { distanceMeters: undefined, timeMinutes: undefined, elevationMeters: undefined, activities: 0 };
}

export const SportTotals: MessageFns<SportTotals> = {
  encode(message: SportTotals, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distanceMeters !== undefined) {
      writer.uint32(9).double(message.distanceMeters);
    }
    if (message.timeMinutes !== undefined) {
      writer.uint32(17).double(message.timeMinutes);
    }
    if (message.elevationMeters !== undefined) {
      writer.uint32(25).double(message.elevationMeters);
    }
    if (message.activities !== 0) {
      writer.uint32(32).int32(message.activities);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SportTotals {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSportTotals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.distanceMeters = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.timeMinutes = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.elevationMeters = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.activities = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseYearMetadata(): YearMetadata {
  return { year: 0, sports: [], totals: {}, lastUpdated: "", aggregationVersion: "" };
}

export const YearMetadata: MessageFns<YearMetadata> = {
  encode(message: YearMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.year !== 0) {
      writer.uint32(8).int32(message.year);
    }
    for (const v of message.sports) {
      writer.uint32(18).string(v!);
    }
    Object.entries(message.totals).forEach(([key, value]) => {
      YearMetadata_TotalsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.lastUpdated !== "") {
      writer.uint32(34).string(message.lastUpdated);
    }
    if (message.aggregationVersion !== "") {
      writer.uint32(42).string(message.aggregationVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YearMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYearMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sports.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = YearMetadata_TotalsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.totals[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastUpdated = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.aggregationVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseYearMetadata_TotalsEntry(): YearMetadata_TotalsEntry {
  return { key: "", value: undefined };
}

export const YearMetadata_TotalsEntry: MessageFns<YearMetadata_TotalsEntry> = {
  encode(message: YearMetadata_TotalsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SportTotals.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): YearMetadata_TotalsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseYearMetadata_TotalsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SportTotals.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
